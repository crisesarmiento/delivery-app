---
description:
globs:
alwaysApply: true
---
# Performance Optimization Guidelines

## React Optimization

### Component Optimization
- Use React.memo for components that render often but with the same props
- Implement useMemo for expensive calculations
- Apply useCallback for function references passed to child components
- Utilize React.lazy and Suspense for code-splitting
- Keep component state as local as possible

### Rendering Optimization
- Avoid unnecessary re-renders by managing component hierarchies
- Move expensive calculations outside of render functions
- Use virtualization for long lists (react-window or react-virtualized)
- Implement debouncing/throttling for frequent events (scroll, resize)
- Avoid inline function definitions in render methods

## Next.js Specific Optimizations

### Image Optimization
- Use Next.js Image component for automatic optimization
- Implement responsive images with appropriate dimensions
- Apply proper loading strategies (eager for above-fold, lazy for below-fold)
- Set correct image priority attributes

### Page Loading
- Leverage static generation (SSG) for content that doesn't change frequently
- Use incremental static regeneration (ISR) for semi-dynamic content
- Apply server-side rendering (SSR) only when necessary
- Implement appropriate caching strategies
- Utilize next/dynamic for component-level code splitting

## Asset Optimization

### JavaScript
- Minimize bundle size through code splitting
- Remove unused dependencies and code
- Use tree-shaking compatible imports
- Implement service workers for caching where appropriate
- Consider using lightweight alternatives for heavy libraries

### CSS and Styling
- Extract critical CSS and inline it
- Minimize unused CSS
- Use efficient selectors
- Implement CSS-in-JS with performance in mind
- Avoid large animation frames

### Media
- Compress and optimize all images
- Serve appropriately sized images for different devices
- Use modern image formats (WebP, AVIF) with fallbacks
- Lazy load media assets when below the fold
- Consider responsive loading strategies for different connections

## Network Optimization

### API and Data Fetching
- Implement data prefetching where appropriate
- Use SWR or React Query for efficient data fetching and caching
- Minimize API payload sizes
- Apply appropriate caching headers
- Consider batch requests to reduce HTTP overhead

### Caching Strategy
- Use service workers for offline capabilities
- Implement browser caching for static assets
- Apply memory caching for frequent calculations
- Consider session storage for user session data
- Use local storage for persistent preferences

## Monitoring and Metrics

### Core Web Vitals
- Optimize for Largest Contentful Paint (LCP) < 2.5s
- Aim for First Input Delay (FID) < 100ms
- Maintain Cumulative Layout Shift (CLS) < 0.1
- Monitor and improve Time to First Byte (TTFB)

### Performance Testing
- Run Lighthouse performance audits regularly
- Use Web Vitals library to measure real user metrics
- Implement performance budgets
- Test on low-end devices and throttled connections
